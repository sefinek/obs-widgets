<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time & Weather Banner</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:transparent;font-family:'Orbitron',monospace;display:flex;justify-content:center;align-items:center;min-height:100vh;font-feature-settings:'tnum' 1}
        .banner{background:rgba(0,0,0,.85);border-radius:16px;padding:28px 31px;display:flex;align-items:center;gap:34px;box-shadow:0 8px 32px rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.1);width:1200px;height:170px}
        .time-section{text-align:center;flex:0 0 auto;width:200px}
        .weather-section{text-align:center;flex:0 0 auto;width:240px}
        .details-section{text-align:center;flex:0 0 auto;width:275px}
        .label{font-size:.9rem;font-weight:700;text-transform:uppercase;letter-spacing:2px;margin-bottom:12px;opacity:.9}
        .utc .label{color:#4CAF50}.poland .label{color:#2196F3}.weather .label{color:#FF9800}.details .label{color:#FF9800}
        .time{font-size:2.8rem;font-weight:900;color:#fff;text-shadow:0 2px 20px rgba(255,255,255,.2);letter-spacing:.5px;margin-bottom:8px;font-variant-numeric:tabular-nums;width:180px;display:inline-block;text-align:center}
        .date{font-size:1rem;color:rgba(255,255,255,.8);letter-spacing:1px;font-variant-numeric:tabular-nums}
        .seconds{font-size:1.8rem;color:#ff6b6b;margin-left:8px;animation:pulse 2s ease-in-out infinite}
        .seconds::before{content:":";margin-right:2px}
        .colon{animation:blink 2s infinite}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
        @keyframes blink{0%,50%{opacity:1}51%,100%{opacity:.3}}
        .separator{width:2px;height:80px;background:linear-gradient(to bottom,transparent 0%,rgba(255,255,255,.1) 20%,rgba(255,255,255,.4) 50%,rgba(255,255,255,.1) 80%,transparent 100%);flex:0 0 auto}
        .weather-content{display:flex;align-items:center;justify-content:center;gap:16px;margin-bottom:8px}
        .weather-icon{font-size:3.2rem;filter:drop-shadow(0 2px 8px rgba(0,0,0,.3))}
        .weather-info{text-align:left}
        .temperature{font-size:2.8rem;font-weight:900;color:#fff;text-shadow:0 2px 20px rgba(255,255,255,.2);font-variant-numeric:tabular-nums;line-height:1}
        .description{font-size:.9rem;color:rgba(255,255,255,.8);text-transform:capitalize;margin-top:4px}
        .location{font-size:.75rem;color:rgba(255,255,255,.6);text-transform:uppercase;letter-spacing:1px}
        .details-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px 16px}
        .detail{display:flex;align-items:center;gap:6px;font-size:.8rem;color:rgba(255,255,255,.8);justify-content:flex-start}
        .detail-icon{font-size:1rem}
        .source-info{font-size:.6rem;opacity:.7}
        .loading{opacity:.6;animation:loading 1.5s ease-in-out infinite}
        @keyframes loading{0%,100%{opacity:.6}50%{opacity:.9}}
    </style>
</head>
<body>
<div class="banner">
    <div class="time-section utc">
        <div class="label">UTC <span id="utc-source" class="source-info">(System)</span></div>
        <div class="time"><span id="utc-h">00</span><span class="colon">:</span><span id="utc-m">00</span><span class="seconds" id="utc-s">00</span></div>
        <div class="date" id="utc-d"></div>
    </div>
    <div class="separator"></div>
    <div class="time-section poland">
        <div class="label">Poland <span id="poland-source" class="source-info">(System)</span></div>
        <div class="time"><span id="poland-h">00</span><span class="colon">:</span><span id="poland-m">00</span><span class="seconds" id="poland-s">00</span></div>
        <div class="date" id="poland-d"></div>
    </div>
    <div class="separator"></div>
    <div class="weather-section weather">
        <div class="label">Weather</div>
        <div class="weather-content">
            <div class="weather-icon" id="weather-icon">üå§Ô∏è</div>
            <div class="weather-info">
                <div class="temperature loading" id="temperature">--¬∞C</div>
                <div class="description loading" id="weather-desc">Loading...</div>
            </div>
        </div>
        <div class="location">West Pomeranian, Poland</div>
    </div>
    <div class="separator"></div>
    <div class="details-section details">
        <div class="label">Details</div>
        <div class="details-grid">
            <div class="detail"><span class="detail-icon">üíß</span><span id="humidity">--%</span></div>
            <div class="detail"><span class="detail-icon">üìä</span><span id="pressure">-- hPa</span></div>
            <div class="detail"><span class="detail-icon">üå¨Ô∏è</span><span id="wind">-- km/h</span></div>
            <div class="detail"><span class="detail-icon">‚òÄÔ∏è</span><span id="uv">UV --</span></div>
            <div class="detail"><span class="detail-icon">üëÅÔ∏è</span><span id="visibility">-- km</span></div>
            <div class="detail"><span class="detail-icon">üåÖ</span><span id="sun-times">--:-- / --:--</span></div>
        </div>
    </div>
</div>

<script>
    'use strict';

    const $ = id => document.getElementById(id);

    const elements = {
        utcHour: $('utc-h'),
        utcMinute: $('utc-m'),
        utcSecond: $('utc-s'),
        utcDate: $('utc-d'),
        utcSource: $('utc-source'),
        polandHour: $('poland-h'),
        polandMinute: $('poland-m'),
        polandSecond: $('poland-s'),
        polandDate: $('poland-d'),
        polandSource: $('poland-source'),
        weatherIcon: $('weather-icon'),
        temperature: $('temperature'),
        weatherDescription: $('weather-desc'),
        humidity: $('humidity'),
        pressure: $('pressure'),
        wind: $('wind'),
        uv: $('uv'),
        visibility: $('visibility'),
        sunTimes: $('sun-times')
    };

    let utcEpoch = 0;
    let performanceAtSync = 0;
    let hasUTCSync = true;

    const WEATHER_UPDATE_INTERVAL = 600000;
    const TIME_SYNC_INTERVAL = 300000;
    const MAX_DRIFT_MS = 2000;
    const DEBUG_ENABLED = true;

    const logger = {
        debug: (message, data = null) => {
            if (!DEBUG_ENABLED) return;
            const timestamp = new Date().toISOString();
            console.log(`[DEBUG ${timestamp}] ${message}`, data || '');
        },
        info: (message, data = null) => {
            const timestamp = new Date().toISOString();
            console.log(`[INFO ${timestamp}] ${message}`, data || '');
        },
        warn: (message, data = null) => {
            const timestamp = new Date().toISOString();
            console.warn(`[WARN ${timestamp}] ${message}`, data || '');
        },
        error: (message, data = null) => {
            const timestamp = new Date().toISOString();
            console.error(`[ERROR ${timestamp}] ${message}`, data || '');
        },
        performance: (label, startTime) => {
            if (!DEBUG_ENABLED) return;
            const duration = performance.now() - startTime;
            const timestamp = new Date().toISOString();
            console.log(`[PERF ${timestamp}] ${label}: ${duration.toFixed(2)}ms`);
        }
    };

    function buildTimestamp(dateObj) {
        return Date.UTC(
            dateObj.year,
            dateObj.month - 1,
            dateObj.day,
            dateObj.hour,
            dateObj.minute,
            dateObj.seconds,
            dateObj.milliSeconds || 0
        );
    }

    function fetchWithTimeout(url) {
        const startTime = performance.now();
        logger.debug('Starting API request', { url });

        return fetch(url).then(response => {
            logger.performance(`API request to ${new URL(url).hostname}`, startTime);
            logger.debug('API response received', {
                url,
                status: response.status,
                ok: response.ok
            });
            return response;
        });
    }

    async function syncUTCTime() {
        const syncStartTime = performance.now();
        logger.debug('Starting UTC time synchronization');

        try {
            const response = await fetchWithTimeout('https://timeapi.io/api/Time/current/zone?timeZone=UTC');
            const timeData = await response.json();
            const serverTime = buildTimestamp(timeData);
            const currentPerformance = performance.now();
            const systemTime = Date.now();
            const timeDifference = serverTime - systemTime;

            logger.debug('UTC sync successful', {
                serverTime: new Date(serverTime).toISOString(),
                systemTime: new Date(systemTime).toISOString(),
                difference: `${timeDifference}ms`,
                timeData
            });

            utcEpoch = serverTime;
            performanceAtSync = currentPerformance;
            elements.utcSource.textContent = '(TimeAPI)';

            logger.performance('UTC time synchronization', syncStartTime);
            logger.info('UTC time synchronized via TimeAPI', {
                accuracy: `¬±${Math.abs(timeDifference)}ms`
            });
        } catch (error) {
            logger.error('TimeAPI UTC sync failed', {
                error: error.message,
                fallback: 'system time'
            });
            utcEpoch = 0;
            performanceAtSync = 0;
            elements.utcSource.textContent = '(System)';
            logger.info('Falling back to system time for UTC display');
        }
    }

    async function checkPolandTimeAPI() {
        const checkStartTime = performance.now();
        logger.debug('Checking Poland TimeAPI availability');

        try {
            const response = await fetchWithTimeout('https://timeapi.io/api/Time/current/zone?timeZone=Europe/Warsaw');
            const timeData = await response.json();

            logger.debug('Poland TimeAPI check successful', {
                serverTime: timeData.dateTime,
                timezone: timeData.timeZone
            });

            elements.polandSource.textContent = '(TimeAPI)';
            logger.performance('Poland TimeAPI check', checkStartTime);
            logger.info('Poland time will use TimeAPI');
        } catch (error) {
            logger.warn('Poland TimeAPI check failed', {
                error: error.message,
                fallback: 'system time'
            });
            elements.polandSource.textContent = '(System)';
            logger.info('Poland time will use system time');
        }
    }

    const formatters = {
        utcTime: new Intl.DateTimeFormat('en-GB', {
            timeZone: 'UTC',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        }),
        utcDate: new Intl.DateTimeFormat('en-GB', {
            timeZone: 'UTC',
            day: 'numeric',
            month: 'short',
            year: 'numeric'
        }),
        polandTime: new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Warsaw',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        }),
        polandDate: new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Warsaw',
            day: 'numeric',
            month: 'short',
            year: 'numeric'
        }),
        polandHourly: new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Warsaw',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            hour12: false
        })
    };

    function getFormatterParts(formatter, timestamp) {
        const parts = formatter.formatToParts(new Date(timestamp));
        const partsObject = {};
        for (const part of parts) {
            partsObject[part.type] = part.value;
        }
        return partsObject;
    }

    function getCurrentUTCTimestamp() {
        if (utcEpoch > 0) {
            return utcEpoch + (performance.now() - performanceAtSync);
        }
        return Date.now();
    }

    let clockUpdateCount = 0;
    let lastClockLogTime = 0;

    function updateClockDisplay() {
        if (!hasUTCSync) {
            requestAnimationFrame(updateClockDisplay);
            return;
        }

        const updateStartTime = performance.now();
        const currentTime = getCurrentUTCTimestamp();
        clockUpdateCount++;

        const utcTimeParts = getFormatterParts(formatters.utcTime, currentTime);
        const utcDateParts = getFormatterParts(formatters.utcDate, currentTime);
        const polandTimeParts = getFormatterParts(formatters.polandTime, currentTime);
        const polandDateParts = getFormatterParts(formatters.polandDate, currentTime);

        elements.utcHour.textContent = utcTimeParts.hour;
        elements.utcMinute.textContent = utcTimeParts.minute;
        elements.utcSecond.textContent = utcTimeParts.second;
        elements.utcDate.textContent = `${utcDateParts.day} ${utcDateParts.month} ${utcDateParts.year}`;

        elements.polandHour.textContent = polandTimeParts.hour;
        elements.polandMinute.textContent = polandTimeParts.minute;
        elements.polandSecond.textContent = polandTimeParts.second;
        elements.polandDate.textContent = `${polandDateParts.day} ${polandDateParts.month} ${polandDateParts.year}`;
        const now = Date.now();
        if (now - lastClockLogTime > 30000) {
            logger.debug('Clock performance stats', {
                updates: clockUpdateCount,
                avgUpdateTime: `${((performance.now() - updateStartTime)).toFixed(2)}ms`,
                usingTimeAPI: utcEpoch > 0,
                currentUTC: new Date(currentTime).toISOString()
            });
            lastClockLogTime = now;
        }

        const nextUpdateDelay = 1000 - Math.floor(currentTime % 1000);
        setTimeout(updateClockDisplay, nextUpdateDelay);
    }

    const weatherIcons = {
        0: { day: '‚òÄÔ∏è', night: 'üåô' },
        1: { day: 'üå§Ô∏è', night: 'üåô' },
        2: { day: '‚õÖ', night: '‚òÅÔ∏è' },
        3: { day: '‚òÅÔ∏è', night: '‚òÅÔ∏è' },
        45: { day: 'üå´Ô∏è', night: 'üå´Ô∏è' },
        48: { day: 'üå´Ô∏è', night: 'üå´Ô∏è' },
        51: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' },
        53: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' },
        55: { day: 'üå¶Ô∏è', night: 'üåßÔ∏è' },
        61: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' },
        63: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' },
        65: { day: 'üåßÔ∏è', night: 'üåßÔ∏è' },
        71: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' },
        73: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' },
        75: { day: 'üå®Ô∏è', night: 'üå®Ô∏è' },
        95: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' },
        96: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' },
        99: { day: '‚õàÔ∏è', night: '‚õàÔ∏è' }
    };

    const weatherDescMap = {
        0: 'clear sky',
        1: 'mainly clear',
        2: 'partly cloudy',
        3: 'overcast',
        45: 'fog',
        48: 'depositing rime fog',
        51: 'light drizzle',
        53: 'moderate drizzle',
        55: 'dense drizzle',
        61: 'slight rain',
        63: 'moderate rain',
        65: 'heavy rain',
        71: 'slight snow',
        73: 'moderate snow',
        75: 'heavy snow',
        95: 'thunderstorm',
        96: 'thunderstorm with hail',
        99: 'thunderstorm with heavy hail'
    };

    const windDirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];

    function getWindDirection(degrees) {
        return windDirs[Math.round(degrees / 22.5) % 16];
    }

    function getPolandHourlyKey() {
        const parts = getFormatterParts(formatters.polandHourly, new Date());
        return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:00`;
    }

    async function updateWeatherData() {
        const weatherStartTime = performance.now();
        logger.debug('Starting weather data update');

        try {
            const weatherUrl = 'https://api.open-meteo.com/v1/forecast?latitude=53.42&longitude=14.56&current_weather=true&hourly=temperature_2m,relative_humidity_2m,weathercode,pressure_msl,wind_speed_10m,wind_direction_10m,uv_index,visibility&daily=sunrise,sunset&timezone=Europe%2FWarsaw';
            const response = await fetchWithTimeout(weatherUrl);
            const weatherData = await response.json();

            logger.debug('Weather API response received', {
                hasCurrentWeather: !!weatherData.current_weather,
                hasHourlyData: !!weatherData.hourly,
                hasDailyData: !!weatherData.daily,
                dataTimestamp: weatherData.current_weather?.time
            });

            const current = weatherData.current_weather;
            const hourly = weatherData.hourly;
            const daily = weatherData.daily;
            const currentHourKey = getPolandHourlyKey();
            const currentHourIndex = hourly.time.indexOf(currentHourKey);

            logger.debug('Weather data processing', {
                temperature: current.temperature,
                weathercode: current.weathercode,
                windspeed: current.windspeed,
                currentHourKey,
                hourlyDataFound: currentHourIndex >= 0
            });

            elements.temperature.textContent = `${Math.round(current.temperature)}¬∞C`;
            elements.weatherDescription.textContent = weatherDescMap[current.weathercode] || 'unknown';

            const iconData = weatherIcons[current.weathercode];
            elements.weatherIcon.textContent = iconData
                ? (current.is_day ? iconData.day : iconData.night)
                : 'üå§Ô∏è';
            if (currentHourIndex >= 0) {
                const humidity = hourly.relative_humidity_2m?.[currentHourIndex];
                const pressure = hourly.pressure_msl?.[currentHourIndex];
                const uvIndex = hourly.uv_index?.[currentHourIndex];
                const visibility = hourly.visibility?.[currentHourIndex];

                elements.humidity.textContent = Number.isFinite(humidity) ? `${Math.round(humidity)}%` : '--%';
                elements.pressure.textContent = Number.isFinite(pressure) ? `${Math.round(pressure)} hPa` : '-- hPa';
                elements.uv.textContent = `UV ${Number.isFinite(uvIndex) ? Math.round(uvIndex) : '--'}`;
                elements.visibility.textContent = Number.isFinite(visibility) ? `${Math.round(visibility / 1000)} km` : '-- km';
            }

            const windSpeed = Math.round(current.windspeed || 0);
            const windDirection = getWindDirection(current.winddirection || 0);
            elements.wind.textContent = `${windSpeed} km/h ${windDirection}`;
            if (daily.sunrise?.[0] && daily.sunset?.[0]) {
                const sunrise = new Date(daily.sunrise[0]).toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const sunset = new Date(daily.sunset[0]).toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                elements.sunTimes.textContent = `${sunrise} / ${sunset}`;
            }

            elements.temperature.classList.remove('loading');
            elements.weatherDescription.classList.remove('loading');

            logger.performance('Weather data update', weatherStartTime);
            logger.info('Weather data updated successfully', {
                temperature: `${Math.round(current.temperature)}¬∞C`,
                condition: weatherDescMap[current.weathercode] || 'unknown',
                wind: `${Math.round(current.windspeed || 0)} km/h`,
                hasDetailedData: currentHourIndex >= 0
            });
        } catch (error) {
            logger.error('Weather update failed', {
                error: error.message,
                duration: `${(performance.now() - weatherStartTime).toFixed(2)}ms`
            });
            elements.temperature.textContent = '--¬∞C';
            elements.weatherDescription.textContent = 'Unavailable';
            logger.info('Weather display set to unavailable state');
        }
    }

    (async () => {
        const appStartTime = performance.now();
        logger.info('Starting Time & Weather Banner application');

        logger.debug('Starting clock display with system time');
        updateClockDisplay();

        logger.debug('Starting parallel initialization of APIs');
        const initializationTasks = [
            syncUTCTime(),
            checkPolandTimeAPI(),
            updateWeatherData()
        ];

        const results = await Promise.allSettled(initializationTasks);
        const initResults = {
            utcSync: results[0].status,
            polandCheck: results[1].status,
            weather: results[2].status
        };

        logger.info('Initialization completed', initResults);
        logger.performance('Full application initialization', appStartTime);

        logger.debug('Setting up periodic weather updates', {
            interval: `${WEATHER_UPDATE_INTERVAL / 1000}s`
        });
        setInterval(() => {
            logger.debug('Periodic weather update triggered');
            updateWeatherData();
        }, WEATHER_UPDATE_INTERVAL);

        logger.debug('Setting up periodic time synchronization', {
            interval: `${TIME_SYNC_INTERVAL / 1000}s`,
            maxDrift: `${MAX_DRIFT_MS}ms`
        });

        setInterval(async () => {
            logger.debug('Periodic time sync triggered');
            const beforeSync = getCurrentUTCTimestamp();

            try {
                await syncUTCTime();
            } catch (error) {
                logger.error('Periodic UTC sync failed', { error: error.message });
            }

            const afterSync = getCurrentUTCTimestamp();
            const timeDrift = afterSync - beforeSync;

            if (Math.abs(timeDrift) > MAX_DRIFT_MS) {
                utcEpoch -= timeDrift;
                logger.warn('Time drift detected and corrected', {
                    drift: `${timeDrift}ms`,
                    threshold: `${MAX_DRIFT_MS}ms`
                });
            } else {
                logger.debug('Time drift within acceptable range', {
                    drift: `${timeDrift}ms`
                });
            }
        }, TIME_SYNC_INTERVAL);

        logger.info('Time & Weather Banner initialized successfully', {
            totalTime: `${(performance.now() - appStartTime).toFixed(2)}ms`,
            debugMode: DEBUG_ENABLED
        });
    })();
</script>
</body>
</html>
